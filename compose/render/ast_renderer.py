# compose/render/ast_renderer.py
"""Clean renderers for the new AST model"""

import re
from typing import List
from ..model.ast import *

class HTMLRenderer:
    """Render AST to HTML"""

    def render(self, doc: Document, config: dict) -> str:
        """Render document to HTML"""
        # Generate CSS based on config
        css = self._generate_css(config)

        html_parts = [
            '<!DOCTYPE html>',
            '<html lang="en">',
            '<head>',
            '    <meta charset="UTF-8">',
            '    <meta name="viewport" content="width=device-width, initial-scale=1.0">',
            f'    <title>{doc.frontmatter.get("title", "Compose Document")}</title>',
            f'    <meta name="description" content="{doc.frontmatter.get("description", "Document generated by Compose")}">',
            '    <style>',
            css,
            '    </style>',
            '</head>',
            '<body>'
        ]

        for block in doc.blocks:
            html_parts.append(self._render_block(block))

        html_parts.extend(['</body>', '</html>'])
        return '\n'.join(html_parts)

    def _render_block(self, block: BlockElement) -> str:
        """Render a block element to HTML"""
        if isinstance(block, Heading):
            tag = f'h{block.level}'
            content = self._render_inline(block.content)
            return f'<{tag}>{content}</{tag}>'

        elif isinstance(block, Paragraph):
            content = self._render_inline(block.content)
            return f'<p>{content}</p>'

        elif isinstance(block, CodeBlock):
            lang_class = f' language-{block.language}' if block.language else ''
            lang_label = f'<div class="language-label">{block.language}</div>' if block.language else ''
            highlighted_code = self._apply_syntax_highlighting(block.content, block.language)
            return f'''<div class="code-block">
    {lang_label}
    <pre><code{lang_class}>{highlighted_code}</code></pre>
</div>'''

        elif isinstance(block, MathBlock):
            content = block.content.strip()
            # Use basic ASCII fallback - math will be rendered as images
            display_content = self._render_math_ascii(content)
            return f'''<div class="math-block" style="
    background: #fff8dc;
    padding: 1em;
    border-radius: 5px;
    text-align: center;
    margin: 1em 0;
    font-family: 'Times New Roman', serif;
    font-style: italic;
    color: #c92c2c;
    border: 1px solid #ddd;">
    <div class="math-placeholder">
        {display_content}
        <br><small>(Math rendering will be replaced with images)</small>
    </div>
</div>'''

        elif isinstance(block, Blockquote):
            inner_html = '\n'.join(self._render_block(b) for b in block.content)
            return f'<blockquote>\n{inner_html}\n</blockquote>'

        elif isinstance(block, ListBlock):
            tag = 'ol' if block.ordered else 'ul'
            items = []
            for item in block.items:
                content = self._render_inline(item.content)
                checkbox = ''
                if item.checked is not None:
                    checked_attr = 'checked' if item.checked else ''
                    checkbox = f'<input type="checkbox" {checked_attr} disabled> '
                items.append(f'<li>{checkbox}{content}</li>')
            return f'<{tag}>\n' + '\n'.join(items) + f'\n</{tag}>'

        elif isinstance(block, Table):
            html_parts = ['<table>']

            # Header
            if block.headers:
                html_parts.append('<thead><tr>')
                for header_cells in block.headers:
                    header_html = self._render_inline(header_cells)
                    html_parts.append(f'<th>{header_html}</th>')
                html_parts.append('</tr></thead>')

            # Body
            if block.rows:
                html_parts.append('<tbody>')
                for row in block.rows:
                    html_parts.append('<tr>')
                    for cell in row:
                        cell_html = self._render_inline(cell)
                        html_parts.append(f'<td>{cell_html}</td>')
                    html_parts.append('</tr>')
                html_parts.append('</tbody>')

            html_parts.append('</table>')
            return '\n'.join(html_parts)

        elif isinstance(block, HorizontalRule):
            return '<hr>'

        elif isinstance(block, MermaidDiagram):
            return f'<div class="mermaid-diagram">\n<pre>{block.content}</pre>\n</div>'

        else:
            return f'<!-- Unknown block type: {type(block)} -->'

    def _render_inline(self, elements: List[InlineElement]) -> str:
        """Render inline elements to HTML"""
        parts = []
        for element in elements:
            if isinstance(element, Text):
                parts.append(element.content)
            elif isinstance(element, Bold):
                inner = self._render_inline(element.children)
                parts.append(f'<strong>{inner}</strong>')
            elif isinstance(element, Italic):
                inner = self._render_inline(element.children)
                parts.append(f'<em>{inner}</em>')
            elif isinstance(element, Strikethrough):
                inner = self._render_inline(element.children)
                parts.append(f'<del>{inner}</del>')
            elif isinstance(element, CodeInline):
                parts.append(f'<code>{element.content}</code>')
            elif isinstance(element, MathInline):
                content = element.content.strip('$')
                # Use basic ASCII fallback - math will be rendered as images
                parts.append(f'<span class="math" style="font-style: italic; color: #c92c2c;">[{content}]</span>')
            elif isinstance(element, Link):
                parts.append(f'<a href="{element.url}">{element.text}</a>')
            elif isinstance(element, Image):
                parts.append(f'<img src="{element.url}" alt="{element.alt}" style="max-width: 100%;">')
            else:
                parts.append(str(element))
        return ''.join(parts)

    def _generate_css(self, config: dict) -> str:
        """Generate CSS from config"""
        typography = config.get('typography', {})
        colors = config.get('colors', {})
        margins = config.get('margins', {})

        css_parts = []

        # Body styles
        font_family = typography.get('font_family', 'serif')
        font_map = {
            'serif': '-apple-system, BlinkMacSystemFont, "Segoe UI", Georgia, serif',
            'sans-serif': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
            'monospace': '"SF Mono", Monaco, "Cascadia Code", "Roboto Mono", monospace'
        }

        css_parts.append(f'''body {{
    font-family: {font_map.get(font_family, font_map['serif'])};
    line-height: {typography.get('line_height', 1.5)};
    font-size: {typography.get('font_size', 14)}px;
    color: {colors.get('text', '#333333')};
    max-width: {typography.get('line_length', 80) * 8}px;
    margin: {margins.get('top', 20)}px auto {margins.get('bottom', 20)}px auto;
    padding-left: {margins.get('left', 20)}px;
    padding-right: {margins.get('right', 20)}px;
}}''')

        # Heading styles
        heading_scale = typography.get('heading_scale', [2.0, 1.8, 1.6, 1.4, 1.2, 1.1])
        for i in range(1, 7):
            scale = heading_scale[i-1] if i-1 < len(heading_scale) else 1.0
            font_size = typography.get('font_size', 14) * scale
            css_parts.append(f'''h{i} {{
    color: {colors.get('headings', '#222222')};
    font-size: {font_size:.1f}px;
    margin-top: {typography.get('paragraph_spacing', 1.0) * 2}em;
    margin-bottom: {typography.get('paragraph_spacing', 1.0)}em;
    line-height: 1.2;
}}''')

        # Other styles (tables, code, etc.)
        css_parts.extend([
            f'''p {{ margin: {typography.get('paragraph_spacing', 1.0)}em 0; }}''',
            f'''a {{ color: {colors.get('links', '#0066cc')}; text-decoration: none; }}''',
            '''a:hover { text-decoration: underline; }''',
            '''ul, ol { margin: 1em 0; padding-left: 2em; }''',
            '''li { margin: 0.5em 0; }''',
            f'''code {{ background: {colors.get('code_background', '#f4f4f4')}; padding: 2px 4px; border-radius: 3px; font-family: {font_map['monospace']}; font-size: 0.9em; color: #000000; }}''',
            f'''pre {{ background: {colors.get('code_background', '#f4f4f4')}; padding: 1em; border-radius: 5px; overflow-x: auto; margin: 1em 0; font-size: 0.9em; color: #000000; }}''',
            '''pre code { background: none; padding: 0; }''',
            '''table { border-collapse: collapse; width: 100%; margin: 1em 0; }''',
            '''th, td { border: 1px solid #ddd; padding: 8px 12px; text-align: left; }''',
            '''th { background-color: #f2f2f2; font-weight: bold; }''',
            f'''blockquote {{ border-left: 4px solid {colors.get('blockquote_border', '#dddddd')}; padding-left: 1em; margin: 1em 0; color: #666; }}''',
            '''hr { border: none; border-top: 1px solid #eee; margin: 2em 0; }''',
            '''.code-block { position: relative; }''',
            '''.language-label { position: absolute; top: 5px; right: 5px; background: #666; color: white; padding: 2px 6px; border-radius: 3px; font-size: 0.8em; }''',
            '''.math { font-style: italic; color: #c92c2c; }''',
            '''.math-block { background: #fff8dc; padding: 1em; border-radius: 5px; text-align: center; margin: 1em 0; }''',
            '''.syntax-keyword { color: #0000ff !important; font-weight: bold; }''',
            '''.syntax-string { color: #008000 !important; }''',
            '''.syntax-comment { color: #808080 !important; font-style: italic; }''',
            '''.syntax-function { color: #795e26 !important; }''',
            '''.syntax-operator { color: #000000 !important; }'''
        ])

        return '\n        '.join(css_parts)

    def _render_math_box_to_html(self, math_box, original_content):
        """Convert a math box to enhanced HTML with proper mathematical formatting"""
        # Apply advanced mathematical transformations
        enhanced_content = self._apply_mathematical_transformations(original_content)
        
        # Add proper mathematical styling
        return f'<span class="math-enhanced">{enhanced_content}</span>'

    def _apply_mathematical_transformations(self, content):
        """Apply advanced mathematical transformations for better HTML rendering"""
        import re
        # Enhanced mathematical symbol transformations
        transformations = {
            # Integrals with proper sizing
            r'\\int': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∫</span>',
            r'\\iint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∬</span>',
            r'\\iiint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∭</span>',
            r'\\oint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∮</span>',
            
            # Sums and products with proper sizing
            r'\\sum': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∑</span>',
            r'\\prod': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∏</span>',
            
            # Fractions with proper layout
            r'\\frac\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}': r'<span class="fraction"><span class="numerator">\1</span><span class="fraction-bar">―</span><span class="denominator">\2</span></span>',
            
            # Square roots
            r'\\sqrt\{([^}]+)\}': r'<span class="sqrt">√<span style="text-decoration: overline;">\1</span></span>',
            
            # Superscripts and subscripts with proper positioning
            r'\^([^{]|\{[^}]*\})': r'<sup style="font-size: 0.8em;">\1</sup>',
            r'_([^{]|\{[^}]*\})': r'<sub style="font-size: 0.8em;">\1</sub>',
            
            # Clean up braces
            r'\{([^}]+)\}': r'\1',
            
            # Greek letters
            r'\\alpha': 'α', r'\\beta': 'β', r'\\gamma': 'γ', r'\\delta': 'δ',
            r'\\epsilon': 'ε', r'\\zeta': 'ζ', r'\\eta': 'η', r'\\theta': 'θ',
            r'\\iota': 'ι', r'\\kappa': 'κ', r'\\lambda': 'λ', r'\\mu': 'μ',
            r'\\nu': 'ν', r'\\xi': 'ξ', r'\\pi': 'π', r'\\rho': 'ρ',
            r'\\sigma': 'σ', r'\\tau': 'τ', r'\\upsilon': 'υ', r'\\phi': 'φ',
            r'\\chi': 'χ', r'\\psi': 'ψ', r'\\omega': 'ω',
            
            # Mathematical operators
            r'\\infty': '∞', r'\\partial': '∂', r'\\nabla': '∇',
            r'\\pm': '±', r'\\mp': '∓', r'\\times': '×', r'\\div': '÷',
            r'\\cdot': '·', r'\\bullet': '•',
            
            # Relations
            r'\\leq': '≤', r'\\geq': '≥', r'\\neq': '≠', r'\\equiv': '≡',
            r'\\approx': '≈', r'\\sim': '∼', r'\\simeq': '≃',
            
            # Arrows
            r'\\rightarrow': '→', r'\\leftarrow': '←', r'\\leftrightarrow': '↔',
            r'\\Rightarrow': '⇒', r'\\Leftarrow': '⇐', r'\\Leftrightarrow': '⇔',
            
            # Sets
            r'\\emptyset': '∅', r'\\in': '∈', r'\\notin': '∉',
            r'\\subset': '⊂', r'\\supset': '⊃', r'\\subseteq': '⊆', r'\\supseteq': '⊇',
            r'\\cup': '∪', r'\\cap': '∩',
            
            # Logic
            r'\\forall': '∀', r'\\exists': '∃', r'\\neg': '¬',
            r'\\land': '∧', r'\\lor': '∨',
        }
        
        result = content
        for pattern, replacement in transformations.items():
            result = re.sub(pattern, replacement, result)
        
        return result


    def _render_math_ascii(self, latex: str) -> str:
        """Convert LaTeX math to ASCII art for better readability"""
        # Clean up the LaTeX
        latex = latex.strip()
        if latex.startswith('$$') and latex.endswith('$$'):
            latex = latex[2:-2].strip()
        elif latex.startswith('$') and latex.endswith('$'):
            latex = latex[1:-1].strip()

        # Apply ASCII transformations
        result = latex
        result = result.replace('\\int', '∫')
        result = result.replace('\\infty', '∞')
        result = result.replace('\\sqrt', '√')
        result = result.replace('^2', '²')
        result = result.replace('^3', '³')
        result = result.replace('\\pi', 'π')
        result = result.replace('\\alpha', 'α')
        result = result.replace('\\beta', 'β')
        result = result.replace('\\gamma', 'γ')
        result = result.replace('\\delta', 'δ')
        result = result.replace('\\epsilon', 'ε')
        result = result.replace('\\theta', 'θ')
        result = result.replace('\\lambda', 'λ')
        result = result.replace('\\mu', 'μ')
        result = result.replace('\\sigma', 'σ')
        result = result.replace('\\phi', 'φ')
        result = result.replace('\\omega', 'ω')

        # Handle subscripts/superscripts in a simple way
        import re
        result = re.sub(r'_\{([^}]+)\}', r'_{\1}', result)  # Simplify subscripts
        result = re.sub(r'\^\{([^}]+)\}', r'^{\1}', result)  # Simplify superscripts

        return result


    def _apply_syntax_highlighting(self, code: str, language: str) -> str:
        """Apply basic syntax highlighting to code"""
        if not language:
            # Still escape HTML even without highlighting
            return code.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Escape HTML entities first
        escaped_code = code.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

        # Apply syntax highlighting to the escaped code
        if language.lower() in ['python', 'py']:
            # Python highlighting
            escaped_code = re.sub(r'\b(def|class|if|elif|else|for|while|try|except|import|from|return|print)\b', r'@@SPAN_KEYWORD@\1@@/SPAN@@', escaped_code)
            escaped_code = re.sub(r'(".*?")|(\'.*?\')', r'@@SPAN_STRING@\1\2@@/SPAN@@', escaped_code)
            # Fixed comment regex - match from # to end of line but preserve content
            escaped_code = re.sub(r'(#.*)$', r'@@SPAN_COMMENT@\1@@/SPAN@@', escaped_code, flags=re.MULTILINE)

        elif language.lower() in ['javascript', 'js', 'typescript', 'ts']:
            # JavaScript/TypeScript highlighting
            escaped_code = re.sub(r'\b(function|const|let|var|if|else|for|while|return|class|import|export)\b', r'@@SPAN_KEYWORD@\1@@/SPAN@@', escaped_code)
            escaped_code = re.sub(r'(".*?")|(\'.*?\')|(`.*?`)', r'@@SPAN_STRING@\1\2\3@@/SPAN@@', escaped_code)
            escaped_code = re.sub(r'(//.*)$', r'@@SPAN_COMMENT@\1@@/SPAN@@', escaped_code, flags=re.MULTILINE)
            escaped_code = re.sub(r'/\*.*?\*/', r'@@SPAN_COMMENT@\0@@/SPAN@@', escaped_code, flags=re.DOTALL)

        # Replace our markers with actual HTML spans
        escaped_code = escaped_code.replace('@@SPAN_KEYWORD@', '<span class="syntax-keyword">')
        escaped_code = escaped_code.replace('@@SPAN_STRING@', '<span class="syntax-string">')
        escaped_code = escaped_code.replace('@@SPAN_COMMENT@', '<span class="syntax-comment">')
        escaped_code = escaped_code.replace('@@SPAN_NUMBER@', '<span class="syntax-number">')
        escaped_code = escaped_code.replace('@@/SPAN@@', '</span>')

        return escaped_code


class TextRenderer:
    """Render AST to plain text"""

    def render(self, doc: Document, config: dict) -> str:
        """Render document to plain text"""
        output = []
        for block in doc.blocks:
            output.append(self._render_block(block))
        return '\n'.join(output)

    def _render_block(self, block: BlockElement) -> str:
        """Render a block element to text"""
        if isinstance(block, Heading):
            content = self._render_inline(block.content)
            return f"{'#' * block.level} {content}\n"

        elif isinstance(block, Paragraph):
            content = self._render_inline(block.content)
            return f"{content}\n\n"

        elif isinstance(block, CodeBlock):
            return f"```\n{block.content}\n```\n\n"

        elif isinstance(block, MathBlock):
            content = block.content.strip()
            ascii_art = self._render_math_ascii(content)
            if ascii_art != content:
                output = ["┌─ Math Block ─┐\n"]
                for line in ascii_art.split('\n'):
                    if line.strip():
                        output.append(f"│ {line} │\n")
                output.append("└─────────────┘\n\n")
            else:
                output = ["┌─ Math Block ─┐\n"]
                for line in content.split('\n'):
                    if line.strip():
                        output.append(f"│ {line} │\n")
                output.append("└─────────────┘\n\n")
            return ''.join(output)

        elif isinstance(block, Blockquote):
            inner_text = '\n'.join(self._render_block(b).rstrip() for b in block.content)
            lines = inner_text.split('\n')
            quoted_lines = [f"> {line}" if line.strip() else ">" for line in lines]
            return '\n'.join(quoted_lines) + '\n\n'

        elif isinstance(block, ListBlock):
            items = []
            for i, item in enumerate(block.items):
                content = self._render_inline(item.content)
                if block.ordered:
                    prefix = f"{i+1}. "
                else:
                    if item.checked is not None:
                        checkbox = '[x]' if item.checked else '[ ]'
                        prefix = f"{checkbox} "
                    else:
                        prefix = "• "
                items.append(f"{prefix}{content}")
            return '\n'.join(items) + '\n\n'

        elif isinstance(block, Table):
            if not block.headers and not block.rows:
                return ''

            lines = []

            # Headers
            if block.headers:
                header_row = [self._render_inline(header).strip() for header in block.headers]
                lines.append('| ' + ' | '.join(header_row) + ' |')
                lines.append('| ' + ' | '.join('-' * len(cell.strip()) for cell in header_row) + ' |')

            # Rows
            for row in block.rows:
                row_cells = [self._render_inline(cell).strip() for cell in row]
                lines.append('| ' + ' | '.join(row_cells) + ' |')

            return '\n'.join(lines) + '\n\n'

        elif isinstance(block, HorizontalRule):
            return '-' * 40 + '\n\n'

        elif isinstance(block, MermaidDiagram):
            return f"Mermaid Diagram:\n```\n{block.content}\n```\n\n"

        else:
            return f"[Unknown block: {type(block)}]\n\n"

    def _render_inline(self, elements: List[InlineElement]) -> str:
        """Render inline elements to text"""
        parts = []
        for element in elements:
            if isinstance(element, Text):
                parts.append(element.content)
            elif isinstance(element, Bold):
                inner = self._render_inline(element.children)
                parts.append(f"**{inner}**")
            elif isinstance(element, Italic):
                inner = self._render_inline(element.children)
                parts.append(f"*{inner}*")
            elif isinstance(element, Strikethrough):
                inner = self._render_inline(element.children)
                parts.append(f"~~{inner}~~")
            elif isinstance(element, CodeInline):
                parts.append(f"`{element.content}`")
            elif isinstance(element, MathInline):
                content = element.content.strip('$')
                parts.append(f"[{content}]")
            elif isinstance(element, Link):
                parts.append(f"[{element.text}]({element.url})")
            elif isinstance(element, Image):
                parts.append(f"![{element.alt}]({element.url})")
            else:
                parts.append(str(element))
        return ''.join(parts)

    def _render_math_ascii(self, latex: str) -> str:
        """Convert LaTeX math to ASCII art for better readability"""
        # Clean up the LaTeX
        latex = latex.strip()
        if latex.startswith('$$') and latex.endswith('$$'):
            latex = latex[2:-2].strip()
        elif latex.startswith('$') and latex.endswith('$'):
            latex = latex[1:-1].strip()

        # Apply ASCII transformations
        result = latex
        result = result.replace('\\int', '∫')
        result = result.replace('\\infty', '∞')
        result = result.replace('\\sqrt', '√')
        result = result.replace('^2', '²')
        result = result.replace('^3', '³')
        result = result.replace('\\pi', 'π')
        result = result.replace('\\alpha', 'α')
        result = result.replace('\\beta', 'β')
        result = result.replace('\\gamma', 'γ')
        result = result.replace('\\delta', 'δ')
        result = result.replace('\\epsilon', 'ε')
        result = result.replace('\\theta', 'θ')
        result = result.replace('\\lambda', 'λ')
        result = result.replace('\\mu', 'μ')
        result = result.replace('\\sigma', 'σ')
        result = result.replace('\\phi', 'φ')
        result = result.replace('\\omega', 'ω')

        # Handle subscripts/superscripts in a simple way
        import re
        result = re.sub(r'_\{([^}]+)\}', r'_{\1}', result)  # Simplify subscripts
        result = re.sub(r'\^\{([^}]+)\}', r'^{\1}', result)  # Simplify superscripts

        return result

    def _render_math_box_to_html(self, math_box, original_content):
        """Convert a math box to enhanced HTML with proper mathematical formatting"""
        # Apply advanced mathematical transformations
        enhanced_content = self._apply_mathematical_transformations(original_content)
        
        # Add proper mathematical styling
        return f'<span class="math-enhanced">{enhanced_content}</span>'

    def _apply_mathematical_transformations(self, content):
        """Apply advanced mathematical transformations for better HTML rendering"""
        import re
        # Enhanced mathematical symbol transformations
        transformations = {
            # Integrals with proper sizing
            r'\\int': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∫</span>',
            r'\\iint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∬</span>',
            r'\\iiint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∭</span>',
            r'\\oint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∮</span>',
            
            # Sums and products with proper sizing
            r'\\sum': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∑</span>',
            r'\\prod': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∏</span>',
            
            # Fractions with proper layout
            r'\\frac\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}': r'<span class="fraction"><span class="numerator">\1</span><span class="fraction-bar">―</span><span class="denominator">\2</span></span>',
            
            # Square roots
            r'\\sqrt\{([^}]+)\}': r'<span class="sqrt">√<span style="text-decoration: overline;">\1</span></span>',
            
            # Superscripts and subscripts with proper positioning
            r'\^([^{]|\{[^}]*\})': r'<sup style="font-size: 0.8em;">\1</sup>',
            r'_([^{]|\{[^}]*\})': r'<sub style="font-size: 0.8em;">\1</sub>',
            
            # Clean up braces
            r'\{([^}]+)\}': r'\1',
            
            # Greek letters
            r'\\alpha': 'α', r'\\beta': 'β', r'\\gamma': 'γ', r'\\delta': 'δ',
            r'\\epsilon': 'ε', r'\\zeta': 'ζ', r'\\eta': 'η', r'\\theta': 'θ',
            r'\\iota': 'ι', r'\\kappa': 'κ', r'\\lambda': 'λ', r'\\mu': 'μ',
            r'\\nu': 'ν', r'\\xi': 'ξ', r'\\pi': 'π', r'\\rho': 'ρ',
            r'\\sigma': 'σ', r'\\tau': 'τ', r'\\upsilon': 'υ', r'\\phi': 'φ',
            r'\\chi': 'χ', r'\\psi': 'ψ', r'\\omega': 'ω',
            
            # Mathematical operators
            r'\\infty': '∞', r'\\partial': '∂', r'\\nabla': '∇',
            r'\\pm': '±', r'\\mp': '∓', r'\\times': '×', r'\\div': '÷',
            r'\\cdot': '·', r'\\bullet': '•',
            
            # Relations
            r'\\leq': '≤', r'\\geq': '≥', r'\\neq': '≠', r'\\equiv': '≡',
            r'\\approx': '≈', r'\\sim': '∼', r'\\simeq': '≃',
            
            # Arrows
            r'\\rightarrow': '→', r'\\leftarrow': '←', r'\\leftrightarrow': '↔',
            r'\\Rightarrow': '⇒', r'\\Leftarrow': '⇐', r'\\Leftrightarrow': '⇔',
            
            # Sets
            r'\\emptyset': '∅', r'\\in': '∈', r'\\notin': '∉',
            r'\\subset': '⊂', r'\\supset': '⊃', r'\\subseteq': '⊆', r'\\supseteq': '⊇',
            r'\\cup': '∪', r'\\cap': '∩',
            
            # Logic
            r'\\forall': '∀', r'\\exists': '∃', r'\\neg': '¬',
            r'\\land': '∧', r'\\lor': '∨',
        }
        
        result = content
        for pattern, replacement in transformations.items():
            result = re.sub(pattern, replacement, result)
        
        return result
