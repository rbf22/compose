# compose/render/html.py
import re

def render_html(nodes, config):
    """Render nodes to HTML with configurable styling and metadata"""
    typography = config.get('typography', {})
    colors = config.get('colors', {})
    margins = config.get('margins', {})
    features = config.get('features', {})

    # Generate dynamic CSS based on configuration
    css_styles = _generate_css_styles(typography, colors, margins, features)

    # Generate HTML head with metadata
    head_content = _generate_html_head(config)

    output = ['<!DOCTYPE html>',
              '<html lang="en">',
              f'<head>{head_content}',
              '    <style>',
              css_styles,
              '    </style>',
              '</head>',
              '<body>']

    for node in nodes:
        output.append(_render_node_html(node))

    output.extend(['</body>', '</html>'])
    return '\n'.join(output)

def _generate_html_head(config):
    """Generate HTML head content with metadata"""
    title = config.get('title', 'Compose Document')
    description = config.get('description', 'Document generated by Compose')
    author = config.get('author', '')
    date = config.get('date', '')

    head_parts = [
        f'    <meta charset="UTF-8">',
        f'    <meta name="viewport" content="width=device-width, initial-scale=1.0">',
        f'    <title>{title}</title>',
        f'    <meta name="description" content="{description}">',
    ]

    if author:
        head_parts.append(f'    <meta name="author" content="{author}">')

    if date:
        head_parts.append(f'    <meta name="date" content="{date}">')

    # Open Graph meta tags for better social sharing
    head_parts.extend([
        f'    <meta property="og:title" content="{title}">',
        f'    <meta property="og:description" content="{description}">',
        f'    <meta property="og:type" content="article">',
    ])

    return '\n'.join(head_parts)

def _generate_css_styles(typography, colors, margins, features):
    """Generate CSS styles based on configuration"""
    font_family_map = {
        'serif': '-apple-system, BlinkMacSystemFont, "Segoe UI", Georgia, serif',
        'sans-serif': '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
        'monospace': '"SF Mono", Monaco, "Cascadia Code", "Roboto Mono", monospace'
    }

    css = []

    # Base body styles
    body_font = font_family_map.get(typography.get('font_family', 'serif'), font_family_map['serif'])
    css.append(f'''body {{
        font-family: {body_font};
        line-height: {typography.get('line_height', 1.5)};
        font-size: {typography.get('font_size', 14)}px;
        color: {colors.get('text', '#333333')};
        max-width: {typography.get('line_length', 80) * 8}px; /* Rough character to pixel conversion */
        margin: {margins.get('top', 20)}px auto {margins.get('bottom', 20)}px auto;
        padding-left: {margins.get('left', 20)}px;
        padding-right: {margins.get('right', 20)}px;
    }}''')

    # Heading styles with scaling
    heading_scale = typography.get('heading_scale', [2.0, 1.8, 1.6, 1.4, 1.2, 1.1])
    for i in range(1, 7):
        scale = heading_scale[i-1] if i-1 < len(heading_scale) else 1.0
        font_size = typography.get('font_size', 14) * scale
        css.append(f'''h{i} {{
            color: {colors.get('headings', '#222222')};
            font-size: {font_size:.1f}px;
            margin-top: {typography.get('paragraph_spacing', 1.0) * 2}em;
            margin-bottom: {typography.get('paragraph_spacing', 1.0)}em;
            line-height: 1.2;
        }}''')

    # Paragraph spacing
    css.append(f'''p {{
        margin: {typography.get('paragraph_spacing', 1.0)}em 0;
    }}''')

    # Link colors
    css.append(f'''a {{
        color: {colors.get('links', '#0066cc')};
        text-decoration: none;
    }}
    a:hover {{
        text-decoration: underline;
    }}''')

    # List styling
    css.append('''ul {
        margin: 1em 0;
        padding-left: 2em;
    }
    li {
        margin: 0.5em 0;
    }''')

    # Code styling
    css.append(f'''code {{
        background: {colors.get('code_background', '#f4f4f4')};
        padding: 2px 4px;
        border-radius: 3px;
        font-family: {font_family_map['monospace']};
        font-size: 0.9em;
    }}
    pre {{
        background: {colors.get('code_background', '#f4f4f4')};
        padding: 1em;
        border-radius: 5px;
        overflow-x: auto;
        margin: 1em 0;
        font-size: 0.9em;
    }}
    pre code {{
        background: none;
        padding: 0;
    }}''')

    # Table styling
    css.append('''table {
        border-collapse: collapse;
        width: 100%;
        margin: 1em 0;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px 12px;
        text-align: left;
    }
    th {
        background-color: #f2f2f2;
        font-weight: bold;
    }''')

    # Blockquote styling
    css.append(f'''blockquote {{
        border-left: 4px solid {colors.get('blockquote_border', '#dddddd')};
        padding-left: 1em;
        margin: 1em 0;
        color: #666;
    }}''')

    # Horizontal rule
    css.append('''hr {
        border: none;
        border-top: 1px solid #eee;
        margin: 2em 0;
    }''')

    # Code block with language label
    css.append('''.code-block {
        position: relative;
    }
    .language-label {
        position: absolute;
        top: 5px;
        right: 5px;
        background: #666;
        color: white;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 0.8em;
    }''')

    # Math styling
    if features.get('math_rendering', True):
        css.append('''.math {
            font-style: italic;
            color: #c92c2c;
            font-family: 'Times New Roman', 'STIX Two Math', serif;
        }
        .math-block {
            background: #fff8dc;
            padding: 1.5em;
            border-radius: 8px;
            text-align: center;
            margin: 1.5em 0;
            font-family: 'Times New Roman', 'STIX Two Math', serif;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .math-expression {
            font-size: 1.2em;
            line-height: 1.4;
            color: #2c2c2c;
        }
        .math-enhanced {
            font-family: 'Times New Roman', 'STIX Two Math', serif;
        }
        .fraction {
            display: inline-block;
            text-align: center;
            vertical-align: middle;
            margin: 0 0.2em;
        }
        .numerator {
            display: block;
            font-size: 0.9em;
            line-height: 1;
            border-bottom: 1px solid currentColor;
            padding-bottom: 0.1em;
        }
        .denominator {
            display: block;
            font-size: 0.9em;
            line-height: 1;
            padding-top: 0.1em;
        }
        .fraction-bar {
            display: block;
            height: 1px;
            background: currentColor;
            margin: 0.1em 0;
        }
        .sqrt {
            position: relative;
        }
        sup, sub {
            font-size: 0.75em;
            line-height: 0;
            position: relative;
        }
        sup {
            vertical-align: super;
        }
        sub {
            vertical-align: sub;
        }''')

    # Syntax highlighting
    if features.get('syntax_highlighting', True):
        css.append('''
        .syntax-keyword { color: #0000ff; font-weight: bold; }
        .syntax-string { color: #008000; }
        .syntax-comment { color: #808080; font-style: italic; }
        .syntax-function { color: #795e26; }
        .syntax-number { color: #09885a; }
        .syntax-operator { color: #000000; }
        ''')

    return '\n        '.join(css)

def _render_node_html(node):
    """Render a single node to HTML"""
    if node.type == 'heading':
        tag = f'h{node.level}'
        return f'<{tag}>{_render_inline_html(node.text)}</{tag}>'
    elif node.type == 'paragraph':
        return f'<p>{_render_inline_html(node.text)}</p>'
    elif node.type == 'list_item':
        return f'<li>{_render_inline_html(node.text)}</li>'
    elif node.type == 'task_item':
        checkbox = 'checked' if node.checked else ''
        return f'<li><input type="checkbox" {checkbox} disabled> {_render_inline_html(node.text)}</li>'
    elif node.type == 'hr':
        return '<hr>'
    elif node.type == 'code_block':
        return _render_code_block_html(node)
    elif node.type == 'table':
        return _render_table_html(node)
    elif node.type == 'math_block':
        return _render_math_block_html(node)
    elif node.type == 'blockquote':
        return _render_blockquote_html(node)
    elif node.type == 'mermaid_diagram':
        return _render_mermaid_diagram_html(node)
    else:
        return f'<!-- Unknown node type: {node.type} -->'

def _render_inline_html(node):
    """Render inline formatted text to HTML"""
    if isinstance(node, str):
        return node
    elif hasattr(node, 'children') and node.children:
        parts = []
        for child in node.children:
            if isinstance(child, str):
                parts.append(child)
            elif hasattr(child, 'type'):
                if child.type == 'text':
                    parts.append(child.text)
                elif child.type == 'bold':
                    parts.append(f'<strong>{_render_inline_html(child)}</strong>')
                elif child.type == 'italic':
                    parts.append(f'<em>{_render_inline_html(child)}</em>')
                elif child.type == 'strikethrough':
                    parts.append(f'<del>{_render_inline_html(child)}</del>')
                elif child.type == 'bold_italic':
                    parts.append(f'<strong><em>{_render_inline_html(child)}</em></strong>')
                elif child.type == 'code_inline':
                    parts.append(f'<code>{child.text}</code>')
                elif child.type == 'math_inline':
                    # Remove $ delimiters and apply advanced transformations
                    math_content = child.text.strip('$')
                    enhanced_math = _apply_mathematical_transformations(math_content)
                    parts.append(f'<span class="math math-enhanced" style="font-style: italic; color: #c92c2c;">{enhanced_math}</span>')
                elif child.type == 'image':
                    parts.append(f'<img src="{child.text}" alt="{child.text}" style="max-width: 100%;">')
                elif child.type == 'link':
                    parts.append(f'<a href="{child.text}">{child.text}</a>')
                elif child.type == 'blockquote':
                    parts.append(_render_blockquote_html(child))
                else:
                    parts.append(str(child))
            else:
                parts.append(str(child))
        return ''.join(parts)
    else:
        return str(node)

def _render_code_block_html(node):
    """Render a code block to HTML with basic syntax highlighting"""
    language_class = f' language-{node.language}' if node.language else ''
    language_label = f'<div class="language-label">{node.language}</div>' if node.language else ''

    # Apply syntax highlighting if we have a supported language
    highlighted_code = _apply_syntax_highlighting(node.text, node.language)

    return f'''<div class="code-block">
    {language_label}
    <pre><code{language_class}>{highlighted_code}</code></pre>
</div>'''

def _apply_syntax_highlighting(code: str, language: str) -> str:
    """Apply basic syntax highlighting to code"""
    if not language:
        # Still escape HTML even without highlighting
        return code.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    # Escape HTML entities first
    escaped_code = code.replace('&', '&amp;').replace('<', '&lt;').replace('>', '&gt;')

    # Apply syntax highlighting to the escaped code
    if language.lower() in ['python', 'py']:
        # Python highlighting
        escaped_code = re.sub(r'\b(def|class|if|elif|else|for|while|try|except|import|from|return|print)\b', r'@@SPAN_KEYWORD@\1@@/SPAN@@', escaped_code)
        escaped_code = re.sub(r'(".*?")|(\'.*?\')', r'@@SPAN_STRING@\1\2@@/SPAN@@', escaped_code)
        escaped_code = re.sub(r'#.*$', r'@@SPAN_COMMENT@\0@@/SPAN@@', escaped_code, flags=re.MULTILINE)
        escaped_code = re.sub(r'\b\d+\b', r'@@SPAN_NUMBER@\0@@/SPAN@@', escaped_code)

    elif language.lower() in ['javascript', 'js', 'typescript', 'ts']:
        # JavaScript/TypeScript highlighting
        escaped_code = re.sub(r'\b(function|const|let|var|if|else|for|while|return|class|import|export)\b', r'@@SPAN_KEYWORD@\1@@/SPAN@@', escaped_code)
        escaped_code = re.sub(r'(".*?")|(\'.*?\')|(`.*?`)', r'@@SPAN_STRING@\1\2\3@@/SPAN@@', escaped_code)
        escaped_code = re.sub(r'//.*$', r'@@SPAN_COMMENT@\0@@/SPAN@@', escaped_code, flags=re.MULTILINE)
        escaped_code = re.sub(r'/\*.*?\*/', r'@@SPAN_COMMENT@\0@@/SPAN@@', escaped_code, flags=re.DOTALL)
        escaped_code = re.sub(r'\b\d+\b', r'@@SPAN_NUMBER@\0@@/SPAN@@', escaped_code)

    # Replace our markers with actual HTML spans
    escaped_code = escaped_code.replace('@@SPAN_KEYWORD@', '<span class="syntax-keyword">')
    escaped_code = escaped_code.replace('@@SPAN_STRING@', '<span class="syntax-string">')
    escaped_code = escaped_code.replace('@@SPAN_COMMENT@', '<span class="syntax-comment">')
    escaped_code = escaped_code.replace('@@SPAN_NUMBER@', '<span class="syntax-number">')
    escaped_code = escaped_code.replace('@@/SPAN@@', '</span>')

    return escaped_code

def _render_table_html(node):
    """Render a table to HTML"""
    if not node.headers and not node.rows:
        return ''

    html = ['<table>']

    # Header
    if node.headers:
        html.append('<thead><tr>')
        for header in node.headers:
            html.append(f'<th>{_render_inline_html(header)}</th>')
        html.append('</tr></thead>')

    # Body
    if node.rows:
        html.append('<tbody>')
        for row in node.rows:
            html.append('<tr>')
            for cell in row:
                html.append(f'<td>{_render_inline_html(cell)}</td>')
            html.append('</tr>')
        html.append('</tbody>')

    html.append('</table>')
    return '\n'.join(html)

def _render_math_block_html(node):
    """Render a math block to HTML with advanced TeX-style layout"""
    # Remove $$ delimiters and clean up the content
    math_content = node.text.strip()
    if math_content.startswith('$$') and math_content.endswith('$$'):
        math_content = math_content[2:-2].strip()
    elif math_content.startswith('$') and math_content.endswith('$'):
        math_content = math_content[1:-1].strip()

    # Try to use the advanced math layout engine
    try:
        from ..layout.content.math_parser import MathExpressionParser
        from ..layout.engines.math_engine import MathLayoutEngine
        
        parser = MathExpressionParser()
        engine = MathLayoutEngine()
        engine.display_style = True  # Use display style for block math
        
        # Parse the mathematical expression
        math_box = parser.parse_expression(math_content)
        
        # Convert to enhanced HTML with proper mathematical formatting
        enhanced_html = _render_math_box_to_html(math_box, math_content)
        
        return f'''<div class="math-block" style="
            background: #fff8dc;
            padding: 1.5em;
            border-radius: 8px;
            text-align: center;
            margin: 1.5em 0;
            font-family: 'Times New Roman', 'STIX Two Math', serif;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
    <div class="math-expression" style="
        font-size: 1.2em;
        line-height: 1.4;
        color: #2c2c2c;">
        {enhanced_html}
    </div>
</div>'''
        
    except Exception as e:
        # Fallback to basic rendering if advanced engine fails
        return f'''<div class="math-block" style="
            background: #fff8dc;
            padding: 1em;
            border-radius: 5px;
            text-align: center;
            margin: 1em 0;
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: #c92c2c;
            border: 1px solid #ddd;">
    {math_content}
    <div style="font-size: 0.8em; color: #666; margin-top: 0.5em;">
        (Advanced math rendering unavailable: {str(e)[:50]}...)
    </div>
</div>'''


def _render_math_box_to_html(math_box, original_content):
    """Convert a math box to enhanced HTML with proper mathematical formatting"""
    # Apply advanced mathematical transformations
    enhanced_content = _apply_mathematical_transformations(original_content)
    
    # Add proper mathematical styling
    return f'<span class="math-enhanced">{enhanced_content}</span>'


def _apply_mathematical_transformations(content):
    """Apply advanced mathematical transformations for better HTML rendering"""
    # Enhanced mathematical symbol transformations
    transformations = {
        # Integrals with proper sizing
        r'\\int': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∫</span>',
        r'\\iint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∬</span>',
        r'\\iiint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∭</span>',
        r'\\oint': '<span style="font-size: 1.8em; vertical-align: -0.3em;">∮</span>',
        
        # Sums and products with proper sizing
        r'\\sum': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∑</span>',
        r'\\prod': '<span style="font-size: 1.8em; vertical-align: -0.2em;">∏</span>',
        
        # Fractions with proper layout (improved regex)
        r'\\frac\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}\{([^{}]*(?:\{[^{}]*\}[^{}]*)*)\}': r'<span class="fraction"><span class="numerator">\1</span><span class="fraction-bar">―</span><span class="denominator">\2</span></span>',
        
        # Square roots
        r'\\sqrt\{([^}]+)\}': r'<span class="sqrt">√<span style="text-decoration: overline;">\1</span></span>',
        
        # Superscripts and subscripts with proper positioning
        r'\^([^{]|\{[^}]*\})': r'<sup style="font-size: 0.8em;">\1</sup>',
        r'_([^{]|\{[^}]*\})': r'<sub style="font-size: 0.8em;">\1</sub>',
        
        # Clean up braces
        r'\{([^}]+)\}': r'\1',
        
        # Greek letters
        r'\\alpha': 'α', r'\\beta': 'β', r'\\gamma': 'γ', r'\\delta': 'δ',
        r'\\epsilon': 'ε', r'\\zeta': 'ζ', r'\\eta': 'η', r'\\theta': 'θ',
        r'\\iota': 'ι', r'\\kappa': 'κ', r'\\lambda': 'λ', r'\\mu': 'μ',
        r'\\nu': 'ν', r'\\xi': 'ξ', r'\\pi': 'π', r'\\rho': 'ρ',
        r'\\sigma': 'σ', r'\\tau': 'τ', r'\\upsilon': 'υ', r'\\phi': 'φ',
        r'\\chi': 'χ', r'\\psi': 'ψ', r'\\omega': 'ω',
        
        # Mathematical operators
        r'\\infty': '∞', r'\\partial': '∂', r'\\nabla': '∇',
        r'\\pm': '±', r'\\mp': '∓', r'\\times': '×', r'\\div': '÷',
        r'\\cdot': '·', r'\\bullet': '•',
        
        # Relations
        r'\\leq': '≤', r'\\geq': '≥', r'\\neq': '≠', r'\\equiv': '≡',
        r'\\approx': '≈', r'\\sim': '∼', r'\\simeq': '≃',
        
        # Arrows
        r'\\rightarrow': '→', r'\\leftarrow': '←', r'\\leftrightarrow': '↔',
        r'\\Rightarrow': '⇒', r'\\Leftarrow': '⇐', r'\\Leftrightarrow': '⇔',
        
        # Sets
        r'\\emptyset': '∅', r'\\in': '∈', r'\\notin': '∉',
        r'\\subset': '⊂', r'\\supset': '⊃', r'\\subseteq': '⊆', r'\\supseteq': '⊇',
        r'\\cup': '∪', r'\\cap': '∩',
        
        # Logic
        r'\\forall': '∀', r'\\exists': '∃', r'\\neg': '¬',
        r'\\land': '∧', r'\\lor': '∨',
    }
    
    result = content
    for pattern, replacement in transformations.items():
        result = re.sub(pattern, replacement, result)
    
    return result

def _render_blockquote_html(node):
    """Render a blockquote to HTML, handling nested content and new structure"""
    # The blockquote's text is a Node with children containing the parsed content
    if hasattr(node.text, 'children') and node.text.children:
        # Render all children as a single paragraph
        content_html = _render_inline_html(node.text)
        return f'<blockquote>\n<p>{content_html}</p>\n</blockquote>'
    else:
        # Fallback for old structure or simple content
        return f'<blockquote>\n<p>{_render_inline_html(node.text)}</p>\n</blockquote>'

def _render_mermaid_diagram_html(node):
    """Render a Mermaid diagram to HTML (ASCII art in pre block)"""
    return f'<div class="mermaid-diagram">\n<pre>{node.text}</pre>\n</div>'
