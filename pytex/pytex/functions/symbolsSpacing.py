"""Python port of KaTeX's functions/symbolsSpacing.js - spacing symbol handling."""

from __future__ import annotations

from typing import TYPE_CHECKING, Any, Dict, cast

from ..build_common import make_ord, make_span, mathsym
from ..dom_tree import DomNode, assert_symbol_dom_node
from ..tree import DocumentFragment
from ..define_function import define_function_builders
from ..mathml_tree import MathNode, TextNode
from ..parse_error import ParseError

if TYPE_CHECKING:
    from ..options import Options
    from ..parse_node import ParseNode, SpacingParseNode

# CSS-based spacing functions to their CSS class
CSS_SPACE = {
    "\\nobreak": "nobreak",
    "\\allowbreak": "allowbreak",
}

# Regular space characters with optional className
REGULAR_SPACE = {
    " ": {},
    "\\ ": {},
    "~": {"className": "nobreak"},
    "\\space": {},
    "\\nobreakspace": {"className": "nobreak"},
}

# Spacing symbols
define_function_builders({
    "type": "spacing",
    "html_builder": lambda group, options: _spacing_html_builder(group, options),
    "mathml_builder": lambda group, options: _spacing_mathml_builder(group, options),
})


def _spacing_html_builder(group: ParseNode, options: "Options") -> Any:
    """Build HTML for spacing symbols."""
    spacing_group = cast("SpacingParseNode", group)
    text = spacing_group["text"]

    if text in REGULAR_SPACE:
        class_name = REGULAR_SPACE[text].get("className", "")
        # Spaces are generated by adding an actual space
        if spacing_group["mode"] == "text":
            ord_input = cast(Dict[str, Any], spacing_group)
            ord_output = make_ord(ord_input, options, "textord")
            if isinstance(ord_output, DocumentFragment):
                first_child = next(iter(ord_output.children), None)
                ord_node = cast(DomNode, first_child) if first_child is not None else make_span()
            else:
                ord_node = ord_output
            symbol = assert_symbol_dom_node(ord_node)
            if class_name:
                symbol.classes.append(class_name)
            return symbol
        else:
            return make_span(["mspace", class_name],
                           [mathsym(text, spacing_group["mode"], options)],
                           options)

    elif text in CSS_SPACE:
        # Spaces based on just a CSS class
        return make_span(["mspace", CSS_SPACE[text]], [], options)

    else:
        raise ParseError(f'Unknown type of space "{text}"')


def _spacing_mathml_builder(group: ParseNode, options: "Options") -> MathNode:
    """Build MathML for spacing symbols."""
    spacing_group = cast("SpacingParseNode", group)
    text = spacing_group["text"]

    if text in REGULAR_SPACE:
        # Use non-breaking space character
        node = MathNode("mtext", [TextNode("\u00a0")])
    elif text in CSS_SPACE:
        # CSS-based MathML spaces are ignored
        node = MathNode("mspace")
    else:
        raise ParseError(f'Unknown type of space "{text}"')

    return node
